{% extends "base.html" %} {% block scripts %}
<script
    src="https://cdnjs.cloudflare.com/ajax/libs/showdown/2.1.0/showdown.min.js"
    integrity="sha512-LhccdVNGe2QMEfI3x4DVV3ckMRe36TfydKss6mJpdHjNFiV07dFpS2xzeZedptKZrwxfICJpez09iNioiSZ3hA=="
    crossorigin="anonymous"
    referrerpolicy="no-referrer"
></script>
<link
    href="{{ url_for('static', filename='themes/prism.css') }}"
    rel="stylesheet"
/>
{% endblock %} {% block content %}
<!-- Content hidden until loaded -->
<content class="hidden">
    <div class="w-full">
        <!-- Container holding post -->
        <div
            class="outline rounded bg-accent p-5 break-normal"
            id="postContainer"
        ></div>
        <br />
        <!-- Comments for the post -->
        <div class="outline rounded bg-accent p-5 break-normal">
            <h2 class="text-2xl"><b>Comments</b></h2>
            {% if current_user.is_active %}
            <!-- If the user is active, allow comments to be posted -->
            <br />
            <!-- Comment Form -->
            <form
                id="commentForm"
                action=""
                method="post"
                autocomplete="off"
                novalidate
            >
                {{ form.hidden_tag() }}
                <p>
                    {{ form.comment.label }}<br />
                    {{ form.comment(rows=5, class_="px-1 border border-black
                    rounded w-full") }} {% for error in form.comment.errors %}
                    <br />
                    <span class="text-black"><b>[{{error}}]</b></span>
                    {% endfor %}
                </p>
                <br />
                <p class="text-center md:text-start">
                    {{ form.submit(class_="border p-1 border-black rounded
                    bg-accent w-full md:w-auto") }}
                </p>
            </form>
            {% endif %}
            <br />
            <!-- Container holding all comments -->
            <div class="px-1" id="commentsContainer"></div>
        </div>
    </div>
</content>
<script>
    document.addEventListener('DOMContentLoaded', async () => {
        // On load, render the post
        const post = await renderPost();

        // Get the save element
        const save = document.getElementById('save');

        // If the user isn't logged in, remove the save and edit buttones
        if ('{{ current_user.is_active }}' !== 'True') {
            document.getElementById('save').remove();
            document.getElementById('edit').remove();
            
            // Unhide the content
            const content = document.getElementsByTagName('content').item(0);
            content.classList.remove('hidden');
            return;
        }

        // If the post is already saved, disable the save button
        await addEditButton(post);
        await addSaveButton();

        // Import prism syntax highlighting after everything is rendered
        const prismImportScript = document.createElement('script');
        prismImportScript.src =
            '{{ url_for("static", filename="dist/lib/prism.js") }}';
        document.body.appendChild(prismImportScript);
        const content = document.getElementsByTagName('content').item(0);

        // After everything is rendered computationally, unhide everything
        content.classList.remove('hidden');
    });

    async function renderPost() {
        // Get post by id
        const post = await getPost(parseInt('{{ id }}'));
        // Render from markdown
        const converter = new showdown.Converter();
        converter.setOption('emoji', true);
        // Fix newline issues
        const body = converter.makeHtml(
            post.body
                .replaceAll('\n', '\n\n')
                .replace(/(?<=\n)\n/g, '­  \n')
                .replace(/(?<=­ {2})\n(?=---)/g, '\n\n')
        );

        // DOM manipulation to render post

        /* 
        ------
        Header
        ------
        */
        
        const header = document.createElement('div');
        header.id = 'header';

        const headerText = document.createElement('h2');
        headerText.classList.add('text-4xl', 'overflow-y-hidden');

        const headerTextBold = document.createElement('b');
        headerTextBold.textContent = post.header;
        headerTextBold.id = 'title';

        const author = document.createElement('i');
        author.classList.add('text-2xl', 'pl-2');
        author.textContent = 'by ';

        const authorLink = document.createElement('a');
        authorLink.href = `{{ url_for('user', id=authorid) }}`;
        authorLink.classList.add('underline');
        authorLink.textContent = post.username;

        /*
        -------
        Buttons
        -------
        */
        const editButton = document.createElement('button');
        editButton.id = 'edit';
        editButton.classList.add(
            'border',
            'p-1',
            'mx-1',
            'inline-block',
            'border-black',
            'rounded',
            'bg-accent',
            'w-full',
            'md:w-auto'
        );

        const saveButton = document.createElement('button');
        saveButton.id = 'save';
        saveButton.classList.add(
            'border',
            'p-1',
            'mx-1',
            'inline-block',
            'border-black',
            'rounded',
            'bg-accent',
            'w-full',
            'md:w-auto'
        );

        /*
        ----
        Body
        ----
        */
        const bodyDiv = document.createElement('div');
        bodyDiv.id = 'body';
        bodyDiv.classList.add('px-4', 'overflow-y-hidden');
        bodyDiv.innerHTML = body;

        /*
        ---------------
        Append children
        ---------------
        */
        author.appendChild(authorLink);
        headerText.appendChild(headerTextBold);
        headerText.appendChild(document.createElement('br'));
        headerText.appendChild(author);
        headerText.appendChild(document.createElement('br'));
        header.appendChild(headerText);

        const postContainer = document.getElementById('postContainer');
        postContainer.appendChild(header);
        postContainer.appendChild(bodyDiv);
        postContainer.appendChild(document.createElement('br'));
        postContainer.appendChild(editButton);
        postContainer.appendChild(saveButton);

        /*
        --------
        Comments
        --------
        */
        const commentsContainer = document.getElementById('commentsContainer');

        var comments = post.comments;
        // If there are no comments, put 1 comment saying No Comments Yet!
        if (comments.length == 0) {
            comments = [
                {
                    user_id: null,
                    timestamp: null,
                    body: 'No comments yet!',
                },
            ];
        }
        // For each comment, add the comment
        for (comment of comments) {
            const commentDiv = document.createElement('div');
            commentDiv.classList.add(
                'outline',
                'rounded',
                'bg-accent',
                'p-5',
                'mb-5'
            );

            // Each component of the comment initialised
            const commentBody = document.createElement('div');
            const commentHeader = document.createElement('div');
            const commentHeaderNameA = document.createElement('a');
            const commentHeaderName = document.createElement('h3');
            const commentHeaderTime = document.createElement('i');

            if (
                comment.user_id != null &&
                comment.timestamp != null &&
                comment.body != 'No comments yet!'
            ) {
                // If the comment is not the 'No comments yet!' comment, render the comment
                commentHeaderNameA.href = `{{ url_for('user', id='') }}${comment.user_id}`;
                commentHeaderNameA.classList.add('inline');

                commentHeaderName.classList.add('underline', 'inline');
                commentHeaderName.textContent = comment.username;

                commentHeaderNameA.appendChild(commentHeaderName);

                commentHeaderTime.classList.add('opacity-50', 'inline');

                // Use moment.js to format the timestamp
                commentHeaderTime.textContent = ` ${moment(
                    comment.timestamp
                ).fromNow()}`;

                commentHeader.appendChild(commentHeaderNameA);
                commentHeader.appendChild(commentHeaderTime);
                commentDiv.appendChild(commentHeader);
                commentBody.classList.add('px-4', 'pt-4');
            } else {
                commentBody.classList.add('underline');
            }
            commentBody.innerHTML = comment.body;
            commentBody.innerHTML = comment.body;

            // Append comment body and header to comment div
            commentDiv.appendChild(commentBody);

            commentsContainer.appendChild(commentDiv);
        }
        return post;
    }

    async function checkExistenceInCollections() {
        // Check if the post is already saved
        fetched = await fetch(
            '{{ url_for("api_check_existence_in_collections", id=id) }}'
        ).then((res) => res.json());
        return fetched.response;
    }

    async function getPost(id) {
        // Get post from API
        fetched = await fetch('{{ url_for("api_post", id=id) }}').then((res) =>
            res.json()
        );
        return fetched;
    }

    async function addEditButton(post) {
        // Check if the user is the author of the post
        // Comment 1 {% if (authorid == current_user.id) %}
        const edit = document.getElementById('edit');
        edit.textContent = 'Edit';
        edit.onclick = function () {
            // replace body with a textbox
            const body = document.getElementById('body');
            const bodyInput = document.createElement('textarea');
            bodyInput.classList.add(
                'px-1',
                'border',
                'border-black',
                'rounded',
                'w-full',
                'h-max'
            );

            // Keep the height of the textarea the same as the content to avoid a scrollbar
            bodyInput.oninput = function () {
                bodyInput.style.height = 'auto';
                bodyInput.style.height = bodyInput.scrollHeight + 10 + 'px';
            };
            
            // Fill the input with the current body to be edited & fix height
            bodyInput.value = post.body;
            bodyInput.style.height = 'auto';
            bodyInput.style.height = body.scrollHeight + 30 + 'px';
            body.replaceWith(bodyInput);

            // replace header with a textbox
            const title = document.getElementById('title');
            const headerInput = document.createElement('input');
            headerInput.classList.add(
                'text-4xl',
                'overflow-y-hidden',
                'px-1',
                'border',
                'border-black',
                'rounded',
                'w-full'
            );
            headerInput.value = post.header;
            title.replaceWith(headerInput);

            // replace edit button with a save button
            const save = document.getElementById('edit');
            save.id = 'save_changes';
            save.textContent = 'Save Changes';
            save.classList.add(
                'border',
                'p-1',
                'mx-2',
                'inline-block',
                'border-black',
                'rounded',
                'bg-accent',
                'w-full',
                'md:w-auto'
            );
            save.onclick = async () => {
                // Save then reload page
                await fetch("{{ url_for('update_database_entry') }}", {
                    method: 'put',
                    body: JSON.stringify({
                        table_name: 'post',
                        entry_id: parseInt('{{ id }}'),
                        new_data: {
                            header: headerInput.value,
                            body: bodyInput.value,
                        },
                    }),
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });
                location.reload();
            };

            // replace the edit button with a save button
            edit.replaceWith(save);

            // Replace the save button with a delete button
            const deleteButton = document.getElementById('save');
            deleteButton.id = 'delete';
            deleteButton.onclick = async () => {

                // Are you sure?
                if (!confirm('Are you sure you want to delete this post?')) {
                    return;
                }

                // Delete then redirect to home page
                await fetch("{{ url_for('delete_database_entry') }}", {
                    method: 'DELETE',
                    body: JSON.stringify({
                        table_name: 'post',
                        entry_id: parseInt('{{ id }}'),
                    }),
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });
                // Reload the page
                window.location.href = '{{ url_for("winstogram") }}';
            };
            deleteButton.textContent = 'Delete';
            deleteButton.classList.add(
                'border',
                'p-1',
                'inline-block',
                'border-black',
                'rounded',
                'bg-accent',
                'w-full',
                'md:w-auto',
                'hover:cursor-pointer'
            );
            // Make sure delete isn't disabled
            deleteButton.classList.remove('disabled');

            document.getElementById('save').replaceWith(deleteButton);
        };
        
        //{% else %}
        document.getElementById('edit').remove();
        //{% endif %} Comment 2
        return;
    }

    async function addSaveButton() {
        // Check if the post is already saved
        const exists = await checkExistenceInCollections(); // True or False

        if (exists) {
            // If it is saved, disable it & display that it is saved.
            save.classList.add('disabled');
            save.dataset.saved = 'true';
            save.textContent = 'Saved!';
            const content = document.getElementsByTagName('content').item(0);
            content.classList.remove('hidden');
            return;
        } else {
            // If it's not saved, enable it & display that it is not saved.
            save.dataset.saved = 'false';
            save.textContent = 'Save';

            // Add event listener to save button for click event
            save.addEventListener(
                'click',
                async function (event) {
                    // Display 'Saving...' for 1 second although it may not actually take that long
                    save.dataset.saving = 'true';
                    save.textContent = 'Saving...';
                    const time = new Date().getTime();
                    await fetch("{{ url_for('save_post', id=id) }}", {
                        method: 'POST',
                    });

                    const time2 = new Date().getTime();
                    if (time2 - time < 1000) {
                        await wait(1000 - (time2 - time));
                    }

                    // After saving, disable it & display that it is saved.
                    save.classList.add('disabled');
                    save.dataset.saved = 'true';
                    save.textContent = 'Saved!';
                },
                // Only run the save function once
                { once: true }
            );
            return;
        }
    }

    // Create wait() function to wait for a certain amount of time (in ms)
    const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
</script>
{% endblock %}
