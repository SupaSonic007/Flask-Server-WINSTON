{% extends "base.html" %} {% block scripts %}
<script
    src="https://cdnjs.cloudflare.com/ajax/libs/showdown/2.1.0/showdown.min.js"
    integrity="sha512-LhccdVNGe2QMEfI3x4DVV3ckMRe36TfydKss6mJpdHjNFiV07dFpS2xzeZedptKZrwxfICJpez09iNioiSZ3hA=="
    crossorigin="anonymous"
    referrerpolicy="no-referrer"
></script>
<link
    href="{{ url_for('static', filename='themes/prism.css') }}"
    rel="stylesheet"
/>
{% endblock %} {% block content %}
<content class="hidden">
    <div class="w-full">
        <div
            class="outline rounded bg-accent p-5 break-normal"
            id="postContainer"
        ></div>
        <br />
        <div class="outline rounded bg-accent p-5 break-normal">
            <h2 class="text-2xl"><b>Comments</b></h2>
            {% if current_user.is_active %}
            <br />
            <form
                id="commentForm"
                action=""
                method="post"
                autocomplete="off"
                novalidate
            >
                {{ form.hidden_tag() }}
                <p>
                    {{ form.comment.label }}<br />
                    {{ form.comment(rows=5, class_="px-1 border border-black
                    rounded w-full") }} {% for error in form.comment.errors %}
                    <br />
                    <span class="text-black"><b>[{{error}}]</b></span>
                    {% endfor %}
                </p>
                <br />
                <p class="text-center md:text-start">
                    {{ form.submit(class_="border p-1 border-black rounded
                    bg-accent w-full md:w-auto") }}
                </p>
            </form>
            {% endif %}
            <br />
            <div class="px-1" id="commentsContainer"></div>
        </div>
    </div>
</content>
<script>
    document.addEventListener('DOMContentLoaded', async () => {
        await renderPost();

        const save = document.getElementById('save');

        if ('{{ current_user.is_active }}' !== 'True') {
            document.getElementById('save').remove();
            document.getElementById('edit').remove();
            const content = document.getElementsByTagName('content').item(0);
            content.classList.remove('hidden');
            return;
        }

        // If the post is already saved, disable the save button
        await addEditButton();
        await addSaveButton();

        // Import prism syntax highlighting after everything is rendered
        const prismImportScript = document.createElement('script');
        prismImportScript.src =
            '{{ url_for("static", filename="dist/lib/prism.js") }}';
        document.body.appendChild(prismImportScript);
        const content = document.getElementsByTagName('content').item(0);
        
        // After everything is rendered computationally, unhide everything
        content.classList.remove('hidden');
    });

    async function renderPost() {
        const post = await getPost(parseInt('{{ id }}'));
        const converter = new showdown.Converter();
        converter.setOption('emoji', true);
        const body = converter.makeHtml(
            post.body
                .replace(/(?<=\n)\n/g, '­  \n')
                .replace(/(?<=­ {2})\n(?=---)/g, '\n\n')
        );

        // DOM manipulation to render post
        const header = document.createElement('div');
        header.id = 'header';

        const headerText = document.createElement('h2');
        headerText.classList.add('text-4xl', 'overflow-y-hidden');

        const headerTextBold = document.createElement('b');
        headerTextBold.textContent = post.header;

        const author = document.createElement('i');
        author.classList.add('text-2xl', 'pl-2');
        author.textContent = 'by ';

        const authorLink = document.createElement('a');
        authorLink.href = `{{ url_for('user', id=authorid) }}`;
        authorLink.classList.add('underline');
        authorLink.textContent = post.username;

        const editButton = document.createElement('button');
        editButton.id = 'edit';
        editButton.classList.add(
            'border',
            'p-1',
            'mx-2',
            'inline-block',
            'border-black',
            'rounded',
            'bg-accent',
            'w-full',
            'md:w-auto'
        );

        const saveButton = document.createElement('button');
        saveButton.id = 'save';
        saveButton.classList.add(
            'border',
            'p-1',
            'inline-block',
            'border-black',
            'rounded',
            'bg-accent',
            'w-full',
            'md:w-auto'
        );

        const bodyDiv = document.createElement('div');
        bodyDiv.id = 'body';
        bodyDiv.classList.add('px-4', 'overflow-y-hidden');
        bodyDiv.innerHTML = body;

        author.appendChild(authorLink);
        headerText.appendChild(headerTextBold);
        headerText.appendChild(document.createElement('br'));
        headerText.appendChild(author);
        headerText.appendChild(document.createElement('br'));
        header.appendChild(headerText);

        const postContainer = document.getElementById('postContainer');
        postContainer.appendChild(header);
        postContainer.appendChild(bodyDiv);
        postContainer.appendChild(document.createElement('br'));
        postContainer.appendChild(editButton);
        postContainer.appendChild(saveButton);

        const commentsContainer = document.getElementById('commentsContainer');

        var comments = post.comments;
        if (comments.length == 0) {
            comments = [
                {
                    user_id: null,
                    timestamp: null,
                    body: 'No comments yet!',
                },
            ];
        }
        for (comment of comments) {
            const commentDiv = document.createElement('div');
            commentDiv.classList.add(
                'outline',
                'rounded',
                'bg-accent',
                'p-5',
                'mb-5'
            );

            const commentBody = document.createElement('div');
            const commentHeader = document.createElement('div');
            const commentHeaderNameA = document.createElement('a');
            const commentHeaderName = document.createElement('h3');
            const commentHeaderTime = document.createElement('i');

            if (
                comment.user_id != null &&
                comment.timestamp != null &&
                comment.body != 'No comments yet!'
            ) {
                commentHeaderNameA.href = `{{ url_for('user', id='') }}${comment.user_id}`;
                commentHeaderNameA.classList.add('inline');

                commentHeaderName.classList.add('underline', 'inline');
                commentHeaderName.textContent = comment.username;

                commentHeaderNameA.appendChild(commentHeaderName);

                commentHeaderTime.classList.add('opacity-50', 'inline');
                commentHeaderTime.textContent = ` ${moment(
                    comment.timestamp
                ).fromNow()}`;

                commentHeader.appendChild(commentHeaderNameA);
                commentHeader.appendChild(commentHeaderTime);
                commentDiv.appendChild(commentHeader);
                commentBody.classList.add('px-4', 'pt-4');
            } else {
                commentBody.classList.add('underline');
            }

            commentBody.innerHTML = comment.body;

            commentDiv.appendChild(commentBody);

            commentsContainer.appendChild(commentDiv);
        }
    }

    async function checkExistenceInCollections() {
        fetched = await fetch(
            '{{ url_for("api_check_existence_in_collections", id=id) }}'
        ).then((res) => res.json());
        return fetched.response;
    }

    async function getPost(id) {
        fetched = await fetch('{{ url_for("api_post", id=id) }}').then((res) =>
            res.json()
        );
        return fetched;
    }

    async function addEditButton() {
        // Check if the user is the author of the post
        // Comment 1 {% if (authorid == current_user.id) %}
        const edit = document.getElementById('edit');
        edit.textContent = 'Edit';
        //{% else %}
        document.getElementById('edit').remove()
        //{% endif %} Comment 2
        return
    }

    async function addSaveButton() {
        // Check if the post is already saved
        const exists = await checkExistenceInCollections(); // True or False

        if (exists) {
            // If it is saved, disable it & display that it is saved.
            save.classList.add('disabled');
            save.dataset.saved = 'true';
            save.textContent = 'Saved!';
            const content = document.getElementsByTagName('content').item(0);
            content.classList.remove('hidden');
            return;
        } else {
            // If it's not saved, enable it & display that it is not saved.
            save.dataset.saved = 'false';
            save.textContent = 'Save';

            // Add event listener to save button for click event
            save.addEventListener(
                'click',
                async function (event) {
                    // Display 'Saving...' for 1 second although it may not actually take that long
                    save.dataset.saving = 'true';
                    save.textContent = 'Saving...';
                    const time = new Date().getTime();
                    await fetch("{{ url_for('save_post', id=id) }}", {
                        method: 'POST',
                    });

                    const time2 = new Date().getTime();
                    if (time2 - time < 1000) {
                        await wait(1000 - (time2 - time));
                    }

                    // After saving, disable it & display that it is saved.
                    save.classList.add('disabled');
                    save.dataset.saved = 'true';
                    save.textContent = 'Saved!';
                },
                // Only run the save function once
                { once: true }
            );
            return;
        }
    }

    const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
</script>
{% endblock %}
